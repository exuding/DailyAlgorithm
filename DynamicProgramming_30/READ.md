# 动态规划专题

## 动态规划题的特点
    例1:计数题：
    --机器人走网格求有多少种方式走到右下角（最优一个值可以用动态规划）
    --机器人走网格输出所有走到右下角的路径（不是一个解不可以用动态规划 可用递归 BFS解
    --有多少种方法选出k个数使得和是sum
    例2：求最大值最小值
    --从左上角走到右下角路径的最大数字和
    --最长上升子序列长度
    例3：求存在性
    --取石子游戏，先手是否必胜
    --能不能选出k个数使得和是sum
## 动态规划的三个组成部分
    1.确定状态
    解动态绘画必须开数组，确定开的一个数组f[i]或者f[i][j]代表什么？就是确定状态
    确定状态需要两个意识：
        -最后一步
            以最少硬币题为例，虽然不知道最优解是什么，但是最优策略肯定是k枚硬币a1,a2....ak加起来是27
            所以一定有最后的硬币：ak
            除掉这枚硬币，前面的硬币面值加起来是27-ak
                注意：不关心前面的k-1枚硬币是怎么拼出27-ak的
                     因为是最优策略，所以拼出27-ak的硬币数一定要最少，否则就不是最优策略了
        -子问题
            最少用多少枚硬币可以拼出27-ak的硬币数即是子问题了
            ak的状态又只可能是2，5，7
            f(27) = min{f(27-2)+1,f(27-5)+1,f(25-7)+1}
                --这里为啥不用递归做
                f(x):
                    if x==0 return 0
                    res = max_value
                    if x>=2:res = min(f(x-2)+1,res)
                    if x>=5:res = min(f(x-5)+1,res)
                    if x>=7:res = min(f(x-7)+1,res)
                    return res
                    ***树的执行图****
                    递归会超时 因为不同状态分支下可能又同一个子问题
    2.转移方程
        --f(x) = min{f(x-2)+1,f(x-5)+1,f(x-7)+1}   
    3.初始条件和边界情况
        两个问题：
            1.x-2,x-5,x-7小于0怎么办？
            2.什么时候停下来
        --例如f[-1],f[-2],,,=正无穷 拼不出-1块钱
        所以f[1] = min{f[-1]+1,f[-4]+1,f[-6]+1}=正无穷 拼不出1块钱
        初始条件:f[0] = 0     (用转移方程算不出来的，但是有意义，需要手工定义)
        边界条件：不要越界
    4.计算顺序
        从后往前还是从前往后算
            本例子从前往后算
            初始条件：f[0] = 0
            然后计算：f[1],f[2],.....f[27]
        当我们计算f[x]时，f[x-2],f[x-5],f[x-7]都已经得到结果了 此时从前往后
        
## 1.Coin Change
    最少的硬币组合（类型2）
    #时间复杂度分析 27*3，每一步尝试三种硬币，一共27步
    
    def coinChange(coins, amount):
    a = [amount + 1 for i in range(amount+1)]  # 数组开多大呢 子状态从0-n就开 n+1 子状态从0-n-1就开 n
    # a[amount] = a[amount-ak]+1
    # ak = coins[i]
    a[0] = 0
    for i in range(1, amount+1):
        a[i] = amount + 1  # 假设拼不出来
        for j in coins:
            if i >= j:
                a[i] = min(a[i - j] + 1, a[i])
    if a[amount] == amount + 1:
        a[amount] = -1
    
    
    
